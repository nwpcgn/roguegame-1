class Game {
	constructor() {
		this.display = null
		this.map = {}
		this.engine = null
		this.player = null
		this.pedro = null
		this.ananas = null
	}

	init() {
		this.display = new ROT.Display({ spacing: 1.1 })
		document.body.appendChild(this.display.getContainer())

		this._generateMap()

		const scheduler = new ROT.Scheduler.Simple()
		scheduler.add(this.player, true)
		scheduler.add(this.pedro, true)

		this.engine = new ROT.Engine(scheduler)
		this.engine.start()
	}

	_generateMap() {
		const digger = new ROT.Map.Digger()
		const freeCells = []

		const digCallback = (x, y, value) => {
			if (value) return
			const key = `${x},${y}`
			this.map[key] = '.'
			freeCells.push(key)
		}
		digger.create(digCallback)

		this._generateBoxes(freeCells)
		this._drawWholeMap()

		this.player = this._createBeing(Player, freeCells)
		this.pedro = this._createBeing(Pedro, freeCells)
	}

	_createBeing(What, freeCells) {
		const index = Math.floor(ROT.RNG.getUniform() * freeCells.length)
		const key = freeCells.splice(index, 1)[0]
		const [x, y] = key.split(',').map(Number)
		return new What(x, y, this)
	}

	_generateBoxes(freeCells) {
		for (let i = 0; i < 10; i++) {
			const index = Math.floor(ROT.RNG.getUniform() * freeCells.length)
			const key = freeCells.splice(index, 1)[0]
			this.map[key] = '*'
			if (i === 0) this.ananas = key // erstes Feld mit Ananas
		}
	}

	_drawWholeMap() {
		for (let key in this.map) {
			const [x, y] = key.split(',').map(Number)
			this.display.draw(x, y, this.map[key])
		}
	}
}

class Player {
	constructor(x, y, game) {
		this._x = x
		this._y = y
		this.game = game
		this._draw()
	}

	getSpeed() {
		return 100
	}
	getX() {
		return this._x
	}
	getY() {
		return this._y
	}

	act() {
		this.game.engine.lock()
		window.addEventListener('keydown', this)
	}

	handleEvent(e) {
		const code = e.keyCode
		if (code === 13 || code === 32) {
			this._checkBox()
			return
		}

		const keyMap = {
			38: 0,
			33: 1,
			39: 2,
			34: 3,
			40: 4,
			35: 5,
			37: 6,
			36: 7
		}

		if (!(code in keyMap)) return

		const dir = ROT.DIRS[8][keyMap[code]]
		const newX = this._x + dir[0]
		const newY = this._y + dir[1]
		const newKey = `${newX},${newY}`

		if (!(newKey in this.game.map)) return

		this.game.display.draw(
			this._x,
			this._y,
			this.game.map[`${this._x},${this._y}`]
		)
		this._x = newX
		this._y = newY
		this._draw()
		window.removeEventListener('keydown', this)
		this.game.engine.unlock()
	}

	_draw() {
		this.game.display.draw(this._x, this._y, '@', '#ff0')
	}

	_checkBox() {
		const key = `${this._x},${this._y}`
		if (this.game.map[key] !== '*') {
			alert('There is no box here!')
		} else if (key === this.game.ananas) {
			alert('Hooray! You found an ananas and won this game.')
			this.game.engine.lock()
			window.removeEventListener('keydown', this)
		} else {
			alert('This box is empty :-(')
		}
	}
}

class Pedro {
	constructor(x, y, game) {
		this._x = x
		this._y = y
		this.game = game
		this._draw()
	}

	getSpeed() {
		return 100
	}

	act() {
		const x = this.game.player.getX()
		const y = this.game.player.getY()

		const passableCallback = (x, y) => {
			return `${x},${y}` in this.game.map
		}

		const astar = new ROT.Path.AStar(x, y, passableCallback, { topology: 4 })

		const path = []
		astar.compute(this._x, this._y, (x, y) => {
			path.push([x, y])
		})

		path.shift() // erstes Element = aktuelle Position
		if (path.length === 1) {
			this.game.engine.lock()
			alert('Game over - you were captured by Pedro!')
		} else {
			const [nx, ny] = path[0]
			this.game.display.draw(
				this._x,
				this._y,
				this.game.map[`${this._x},${this._y}`]
			)
			this._x = nx
			this._y = ny
			this._draw()
		}
	}

	_draw() {
		this.game.display.draw(this._x, this._y, 'P', 'red')
	}
}

// Starte das Spiel
const game = new Game()
game.init()
